#pragma once
#include "Game/GameCommon.hpp"
#include "Game/Block.hpp"
#include <vector>
#include "BlockIterator.hpp"
#include <atomic>
#include "BuildingTemplate.hpp"

class World;
class BlockTemplate;
struct BlockPosition;

enum ChunkState
{
	CHUNK_INITIALIZING,		// chunk data structures are being created
	CHUNK_READY,			// initialized but not queued yet
	CHUNK_QUEUED,			// waiting in queue for generation by worker thread
	CHUNK_GENERATING,		// being generated by worker thread
	CHUNK_COMPLETE,			// generation complete, waiting on main thread for processing
	CHUNK_ACTIVE,			// chunk is active part of world terrain
	CHUNK_SUSPENDED,		// chunk is out of range and suspended in memory
	CHUNK_DEACTIVED,		// chunk has been marked for saving and removal
};

enum JobType
{
	JOB_CREATE = 1,
	JOB_LOAD = 2,
	JOB_SAVE = 4,
	JOB_TEST = 0xFFFF,		// this is job wild card
};

class Chunk
{
public:
	virtual ~Chunk();
	Chunk();
	bool Create();
	void CopyTreeTemplateToWorld(BlockTemplate const* tree, int terrainHeight, int dx, int dy);
	void CreateTrees(int baseX, int baseY);
	void CreateVillage(int baseX, int baseY);
	uint8_t DetermineSurfaceTerrain(int offset, float tx, float ty, int* terrainHeight);
	bool TestTreeForBlock(int x, int y);
	bool TestVillageForChunk(int x, int y);
	uint8_t GetBlock(int x, int y, int z);
	uint8_t GetBlock(int index);
	Block* GetBlockPtr(int index);
	void SetBlock(int x, int y, int z, uint8_t value);
	void SetBlock(int index, uint8_t value);
	void SetBlock(IntVec3 position, uint8_t value);
	void CreateBuffers();
	void CreateGeometry();
	Rgba8 BlockFaceLight(BlockIterator block, int face);
	bool IsVisible(int blockIndex, int face);
	AABB3 GetBlockBounds(int index);
	AABB3 GetBlockBounds(int x, int y, int z);

	void Update(float deltaSeconds);
	void Render();
	void WriteChunkToDisc();
	void ReadChunkFromDisc(const char* filename);
	void LinkNeighbors(World const& world);
	void Initialize(IntVec2 worldChunkCoords);
	void Activate(World& world);
	void Deactivate();

	static IntVec2 GetChunkForWorldPosition(Vec3 position);
	static int GetBlockForPosition(Vec3 position);
	static AABB2 GetChunkWorldBounds(int x, int y);
	void TestNeighborNeedsMesh(int x, int y);
	uint8_t ConvertToBlock(BuildingBlock variableBlock);

	bool m_dirty = false;
	bool m_needsMesh = true;
//	std::atomic<int> m_status;
	std::atomic<ChunkState> m_status = CHUNK_INITIALIZING;
	std::vector<Vertex_PCU> m_vertexes;
	std::vector<unsigned int> m_indexes;
	int m_indexCount = 0;
	Block* m_block = nullptr;
	IntVec2 m_chunkCoords = IntVec2::ZERO;
	AABB3 m_worldBounds = AABB3::ZERO_TO_ONE;
	Chunk* m_neighbors[4] = { 0 };

	VertexBuffer* m_immediateVBO_PCU = nullptr;
	IndexBuffer* m_indexBuffer = nullptr;
	// local arrays to store noise data for generating terrain
	float m_humidity[NOISE_ARRAY];
	float m_temperature[NOISE_ARRAY];
	float m_hilliness[NOISE_ARRAY];
	float m_ocean[NOISE_ARRAY];
	float m_forest[NOISE_ARRAY];
	float m_treeDensity[NOISE_ARRAY];
	float m_town[NOISE_ARRAY];
	int m_worldSeed = 0;
	int m_townType = 0;
};